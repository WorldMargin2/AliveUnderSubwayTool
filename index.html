
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手续费计算器</title>
    <script src="./js/chart.min.js"></script>
	<link rel="stylesheet" href="./css/style.css">
</head>
<body>
        <h1 class="app-title">地铁逃生交易行小助手</h1>

        <div class="mobile-menu-container">
            <div class="menu-toggle" onclick="toggleMobileMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <div class="mobile-menu" id="mobile-menu">
                <div class="mobile-menu-item active" onclick="switchTab('medicine'); toggleMobileMenu()">
                    药品
                </div>
                <div class="mobile-menu-item" onclick="switchTab('equipment'); toggleMobileMenu()">
                    装备
                </div>
            </div>
        </div>

        <div id="medicine" class="tab-content active">
            <div class="chart-container">
                <canvas id="medicine-chart"></canvas>
                <div id="medicine-tooltip" class="tooltip"></div>
                <div id="medicine-selection" class="chart-selection"></div>
            </div>

            <div class="input-row">
                <div class="input-item">
                    <label for="medicine-price">期望售价</label>
                    <input type="text" id="medicine-price" placeholder="例如: 10万 或 1000000">
                </div>
            </div>
        </div>

        <div id="equipment" class="tab-content">
            <div class="chart-container">
                <canvas id="equipment-chart"></canvas>
                <div id="equipment-tooltip" class="tooltip"></div>
                <div id="equipment-selection" class="chart-selection"></div>
            </div>

            <div class="input-row">
                <div class="input-item">
                    <label for="equipment-price">期望售价</label>
                    <input type="text" id="equipment-price" placeholder="例如: 10万 或 1000000">
                </div>
                <div class="input-item">
                    <label for="equipment-base-price">统一回收价</label>
                    <input type="text" id="equipment-base-price" placeholder="例如: 27万 或 270000" value="27万">
                </div>
                <div class="input-item">
                    <label for="equipment-entries">词条数</label>
                    <select id="equipment-entries">
                        <option value="1">1词条</option>
                        <option value="2">2词条</option>
                        <option value="3">3词条</option>
                        <option value="4">4词条</option>
                    </select>
                </div>
            </div>
        </div>
    <script>
        // 药品手续费规则
        const medicineFees = [
            {price: 0, rate: 4},
            {price: 200000, rate: 6},
            {price: 300000, rate: 8},
            {price: 400000, rate: 12},
            {price: 500000, rate: 15},
            {price: 600000, rate: 23},
            {price: 700000, rate: 30},
            {price: 800000, rate: 40},
            {price: 900000, rate: 50}
        ];

        // 装备手续费规则
        const equipmentFees = [
            {"1词条": [0, 5], "2词条": [0, 10], "3词条": [0, 20], "4词条": [0, 40], "rate": 4},
            {"1词条": [5, 7.5], "2词条": [10, 15], "3词条": [20, 40], "4词条": [40, 80], "rate": 6},
            {"1词条": [7.5, 10], "2词条": [15, 20], "3词条": null, "4词条": null, "rate": 8},
            {"1词条": [10, 12.5], "2词条": [20, 25], "3词条": [40, 80], "4词条": [80, 95], "rate": 12},
            {"1词条": [12.5, 15], "2词条": [25, 30], "3词条": null, "4词条": [95, 120], "rate": 15},
            {"1词条": [15, 17.5], "2词条": [30, 35], "3词条": null, "4词条": [120, 140], "rate": 23},
            {"1词条": [17.5, 20], "2词条": [35, 40], "3词条": null, "4词条": [140, 160], "rate": 30},
            {"1词条": [20, 22.5], "2词条": [40, 45], "3词条": [80, 90], "4词条": [160, 180], "rate": 40},
            {"1词条": [22.5, 25], "2词条": [45, 50], "3词条": [90, 100], "4词条": [180, Infinity], "rate": 50},
            {"1词条": [25, Infinity], "2词条": [50, Infinity], "3词条": [100, Infinity], "4词条": null, "rate": 80}
        ];

        let medicineChart = null;
        let equipmentChart = null;

        // 切换标签页
        function switchTab(tabName) {
            // 更新标签样式
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            // 激活选中的标签
            if (event && event.target) {
                event.target.classList.add('active');
            }
            document.getElementById(tabName).classList.add('active');

            // 更新移动菜单项状态
            const mobileMenuItems = document.querySelectorAll('.mobile-menu-item');
            mobileMenuItems.forEach(item => {
                item.classList.remove('active');
            });

            // 找到对应的移动菜单项并设置为活动状态
            mobileMenuItems.forEach(item => {
                if (item.getAttribute('onclick').includes(tabName)) {
                    item.classList.add('active');
                }
            });

            // 初始化图表
            if (tabName === 'medicine' && !medicineChart) {
                initMedicineChart();
            } else if (tabName === 'equipment' && !equipmentChart) {
                initEquipmentChart();
            }
        }

        // 切换移动菜单显示状态
        function toggleMobileMenu() {
            const mobileMenu = document.getElementById('mobile-menu');
            mobileMenu.classList.toggle('show');
        }

        // 点击页面其他地方关闭菜单
        document.addEventListener('click', function(event) {
            const mobileMenuContainer = document.querySelector('.mobile-menu-container');
            if (!mobileMenuContainer.contains(event.target)) {
                const mobileMenu = document.getElementById('mobile-menu');
                if (mobileMenu.classList.contains('show')) {
                    mobileMenu.classList.remove('show');
                }
            }
        });

        // 解析价格输入
        function parsePriceInput(text) {
            if (!text) return 0;

            text = text.trim();

            if (text.includes('千万')) {
                const num = parseFloat(text.replace('千万', ''));
                return num * 10000000;
            } else if (text.includes('万')) {
                const num = parseFloat(text.replace('万', ''));
                return num * 10000;
            } else {
                try {
                    return parseFloat(text);
                } catch (e) {
                    return 0;
                }
            }
        }

        // 格式化价格显示
        function formatPrice(price) {
            if (price >= 100000000) {
                return (price / 100000000).toFixed(2) + '亿';
            } else if (price >= 10000000) {
                return (price / 10000000).toFixed(2) + '千万';
            } else if (price >= 10000) {
                return (price / 10000).toFixed(2) + '万';
            } else {
                return price.toFixed(2);
            }
        }

        // 计算药品手续费
        function calculateMedicineFee(price) {
            let feeRate = 0;
            for (const fee of medicineFees) {
                if (price >= fee.price) {
                    feeRate = fee.rate;
                }
            }

            const fee = price * feeRate / 100;
            const actualIncome = price - fee;

            return {
                price: price,
                feeRate: feeRate,
                fee: fee,
                actualIncome: actualIncome
            };
        }

        // 计算装备手续费
        function calculateEquipmentFee(price, entries, basePrice) {
            let feeRate = 0;
            const entriesKey = `${entries}词条`;
            const multiplier = price / basePrice;

            for (const fee of equipmentFees) {
                const rangeValues = fee[entriesKey];
                if (rangeValues && multiplier >= rangeValues[0] && multiplier <= rangeValues[1]) {
                    feeRate = fee.rate;
                    break;
                }
            }

            // 手续费计算：手续费=fees.locate(期望售价/统一回收价)*期望售价
            const fee = price * feeRate / 100;
            const actualIncome = price - fee;

            return {
                multiplier: multiplier,
                entries: entries,
                price: price,
                feeRate: feeRate,
                fee: fee,
                actualIncome: actualIncome
            };
        }

        // 生成药品图表数据
        function generateMedicineChartData() {
            const chartData = [];
            const maxPrice = 1000000; // 100万

            for (let price = 0; price <= maxPrice; price += 10000) { // 每1万一个点
                const result = calculateMedicineFee(price);
                chartData.push({
                    x: price,
                    y: result.actualIncome,
                    feeRate: result.feeRate
                });
            }

            // 添加转折点
            const turningPoints = [];
            for (const fee of medicineFees) {
                if (fee.price <= maxPrice) {
                    const result = calculateMedicineFee(fee.price);
                    turningPoints.push({
                        x: fee.price,
                        y: result.actualIncome,
                        feeRate: result.feeRate
                    });
                }
            }

            // 计算极值点（手续费率变化点）
            const extremePoints = [];
            for (const fee of medicineFees) {
                if (fee.price <= maxPrice) {
                    const result = calculateMedicineFee(fee.price);
                    extremePoints.push({
                        x: fee.price,
                        y: result.actualIncome,
                        feeRate: result.feeRate
                    });
                }
            }

            // 计算最高点（实际收入最高的点）
            let highestPoint = null;
            let maxIncome = 0;
            for (const point of chartData) {
                if (point.y > maxIncome) {
                    maxIncome = point.y;
                    highestPoint = {
                        x: point.x,
                        y: point.y,
                        feeRate: point.feeRate
                    };
                }
            }

            return {
                chartData: chartData,
                turningPoints: turningPoints,
                extremePoints: extremePoints,
                highestPoint: highestPoint,
                maxX: maxPrice
            };
        }

        // 生成装备图表数据
        function generateEquipmentChartData(entries, basePrice) {
            const chartData = [];
            const maxPrice = 50000000; // 固定最大价格5000万
            const step = 100000; // 每10万一个点

            for (let price = 0; price <= maxPrice; price += step) {
                const result = calculateEquipmentFee(price, entries, basePrice);
                chartData.push({
                    x: result.price,
                    y: result.actualIncome,
                    feeRate: result.feeRate
                });
            }

            // 添加极值点（手续费率变化点）
            const extremePoints = [];
            const entriesKey = `${entries}词条`;
            const maxMultiplier = maxPrice / basePrice;
            let lastFeeRate = 0;

            // 找出手续费率变化的点
            for (const fee of equipmentFees) {
                const rangeValues = fee[entriesKey];
                if (rangeValues && rangeValues[0] < maxMultiplier) {
                    // 检查手续费率是否变化
                    if (fee.rate !== lastFeeRate) {
                        // 取区间左端点作为极值点
                        const leftPoint = Math.max(rangeValues[0], 0);
                        const price = basePrice * leftPoint;
                        const result = calculateEquipmentFee(price, entries, basePrice);
                        extremePoints.push({
                            x: result.price,
                            y: result.actualIncome,
                            feeRate: result.feeRate
                        });
                        lastFeeRate = fee.rate;
                    }
                }
            }

            // 找出最高点
            let highestPoint = null;
            if (chartData.length > 0) {
                highestPoint = chartData.reduce((max, point) => 
                    point.y > max.y ? point : max, chartData[0]);
            }

            return {
                chartData: chartData,
                extremePoints: extremePoints,
                highestPoint: highestPoint,
                maxX: maxPrice
            };
        }

        // 初始化药品图表
        function initMedicineChart() {
            const ctx = document.getElementById('medicine-chart').getContext('2d');
            const data = generateMedicineChartData();
            const medicineSelection = document.getElementById('medicine-selection');
            const medicinePriceInput = document.getElementById('medicine-price');

            // 选择区域相关变量
            let isSelecting = false;
            let selectionStart = { x: 0, y: 0 };
            let selectionEnd = { x: 0, y: 0 };

            medicineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: '实际收入',
                            data: data.chartData,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            fill: true,
                            tension: 0.1,
                            pointRadius: 0,
                            // 确保线条只在有效数据范围内绘制
                            spanGaps: false,
                            // 设置数据边界
                            xAxisID: 'x'
                        },
                        {
                            label: '极值点',
                            data: data.extremePoints,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 1)',
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            showLine: false
                        },
                        {
                            label: '最高点',
                            data: data.highestPoint ? [data.highestPoint] : [],
                            borderColor: 'rgba(255, 159, 64, 1)',
                            backgroundColor: 'rgba(255, 159, 64, 1)',
                            pointRadius: 10,
                            pointHoverRadius: 12,
                            pointStyle: 'circle',
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '期望售价'
                            },
                            ticks: {
                                callback: function(value) {
                                    // 显示所有合理的y轴刻度值
                                    if (value >= 0) {
                                        return formatPrice(value);
                                    }
                                    return '';
                                }
                            },
                            // 扩展显示区域，使用5%的范围作为边距
                            min: -data.maxX * 0.05,
                            max: data.maxX * 1.05,
                            // 添加一些边距，使图表不会紧贴边缘
                            afterBuildTicks: function(scale) {
                                scale.ticks = scale.ticks.map(function(tick) {
                                    return tick;
                                });
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '实际收入'
                            },
                            maxTicksLimit: 6,
                            ticks: {
                                callback: function(value) {
                                    // 显示所有合理的y轴刻度值
                                    if (value >= 0) {
                                        return formatPrice(value);
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 20,
                            top: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        tooltip: {
                            enabled: false // 禁用Chart.js默认的tooltip
                        }
                    },
                    onHover: (event, activeElements) => {
                        const canvasPosition = Chart.helpers.getRelativePosition(event, medicineChart);
                        let dataX = medicineChart.scales.x.getValueForPixel(canvasPosition.x);
                        const dataY = medicineChart.scales.y.getValueForPixel(canvasPosition.y);

                        // 检查是否有用户输入的结果，如果有则调整tooltip位置避免重叠
                        const resultDiv = document.getElementById('medicine-chart-result');
                        if (resultDiv && resultDiv.dataset.isUserInput === 'true') {
                            // 获取常驻结果的位置
                            const resultRect = resultDiv.getBoundingClientRect();
                            // 调整tooltip位置，避免与常驻结果重叠
                            const tooltip = document.getElementById('medicine-tooltip');
                            tooltip.style.display = 'block';
                            // 继续执行后续代码，显示tooltip
                        }

                        // 检查是否在最大值范围内
                        const data = medicineChart.data.datasets[0].data;
                        const maxX = Math.max(...data.map(point => point.x));
                        const maxXRange = maxX * 0.02; // 最大值2%的范围

                        // 如果在最大值范围内，使用最大值
                        if (Math.abs(dataX - maxX) < maxXRange) {
                            dataX = maxX;
                        }

                        const tooltip = document.getElementById('medicine-tooltip');
                        tooltip.style.display = 'block';
                        const result = calculateMedicineFee(dataX);
                        tooltip.innerHTML = `
                            <table class="tooltip-table">
                                <tr><td>期望售价:</td><td>${formatPrice(dataX)}</td></tr>
                                <tr><td>手续费率:</td><td>${result.feeRate.toFixed(2)}%</td></tr>
                                <tr><td>手续费:</td><td>${formatPrice(result.fee)}</td></tr>
                                <tr><td>实际收入:</td><td>${formatPrice(result.actualIncome)}</td></tr>
                            </table>
                        `;

                        // 使用鼠标位置定位tooltip，并确保不超出body边界
                        const tooltipRect = tooltip.getBoundingClientRect();
                        const bodyRect = document.body.getBoundingClientRect();

                        let left = event.native.clientX - bodyRect.left + 10;
                        let top = event.native.clientY - bodyRect.top - tooltipRect.height - 10;

                        // 如果有常驻结果显示，调整tooltip位置避免重叠
                        if (resultDiv && resultDiv.dataset.isUserInput === 'true') {
                            const resultRect = resultDiv.getBoundingClientRect();
                            // 如果tooltip会与常驻结果重叠，则调整位置
                            if (left < resultRect.right && left + tooltipRect.width > resultRect.left &&
                                top < resultRect.bottom && top + tooltipRect.height > resultRect.top) {
                                // 将tooltip移到常驻结果的右侧
                                left = resultRect.right + 10;
                                // 如果右侧超出边界，则移到下方
                                if (left + tooltipRect.width > bodyRect.width) {
                                    left = event.native.clientX - bodyRect.left - tooltipRect.width - 10;
                                    // 如果还是超出边界，则移到常驻结果的下方
                                    if (left < 0) {
                                        left = resultRect.left;
                                        top = resultRect.bottom + 10;
                                    }
                                }
                            }
                        }

                        // 检查右边界
                        if (left + tooltipRect.width > bodyRect.width) {
                            left = event.native.clientX - bodyRect.left - tooltipRect.width - 10;
                        }

                        // 检查左边界
                        if (left < 0) {
                            left = 10;
                        }

                        // 检查下边界
                        if (top < 0) {
                            top = event.native.clientY - bodyRect.top + 10;
                        }

                        // 检查上边界
                        if (top + tooltipRect.height > bodyRect.height) {
                            top = bodyRect.height - tooltipRect.height - 10;
                        }

                        tooltip.style.left = left + 'px';
                        tooltip.style.top = top + 'px';

                        // 检查是否靠近极值点
                        let nearExtremePoint = false;
                        let extremePointData = null;
                        const extremePoints = data.extremePoints || [];
                        for (const point of extremePoints) {
                            const distance = Math.abs(point.x - dataX);
                            if (distance < 1000000) { // 如果距离小于100万
                                nearExtremePoint = true;
                                extremePointData = point;
                                break;
                            }
                        }

                        // 检查是否靠近最高点
                        let nearHighestPoint = false;
                        let highestPointData = null;
                        const highestPoint = data.highestPoint;
                        if (highestPoint && !nearExtremePoint) {
                            const distance = Math.abs(highestPoint.x - dataX);
                            if (distance < 1000000) { // 如果距离小于100万
                                nearHighestPoint = true;
                                highestPointData = highestPoint;
                            }
                        }

                        // 如果靠近极值点或最高点，使用它们的值
                        let displayDataX = dataX;
                        if (nearExtremePoint) {
                            displayDataX = extremePointData.x;
                        } else if (nearHighestPoint) {
                            displayDataX = highestPointData.x;
                        }

                        const medicineResult = calculateMedicineFee(displayDataX);
                        tooltip.innerHTML = `
                            <table class="tooltip-table">
                                <tr><td>期望售价:</td><td>${formatPrice(displayDataX)}</td></tr>
                                <tr><td>手续费率:</td><td>${medicineResult.feeRate.toFixed(2)}%</td></tr>
                                <tr><td>手续费:</td><td>${formatPrice(medicineResult.fee)}</td></tr>
                                <tr><td>实际收入:</td><td>${formatPrice(medicineResult.actualIncome)}</td></tr>
                                ${nearExtremePoint ? '<tr><td colspan="2" style="text-align:center;color:#FF6384;font-weight:bold;">极值点</td></tr>' : ''}
                                ${nearHighestPoint ? '<tr><td colspan="2" style="text-align:center;color:#FF9F40;font-weight:bold;">最高点</td></tr>' : ''}
                            </table>
                        `;

                        // 如果靠近极值点或最高点，调整tooltip位置
                        if (nearExtremePoint || nearHighestPoint) {
                            const point = nearExtremePoint ? extremePointData : highestPointData;
                            const pointPixelX = medicineChart.scales.x.getPixelForValue(point.x);
                            const pointPixelY = medicineChart.scales.y.getPixelForValue(point.y);
                            const canvasRect = medicineChart.canvas.getBoundingClientRect();
                            
                            left = canvasRect.left + pointPixelX + 10;
                            top = canvasRect.top + pointPixelY - tooltipRect.height - 10;
                            
                            // 确保tooltip不超出边界
                            if (left + tooltipRect.width > bodyRect.width) {
                                left = canvasRect.left + pointPixelX - tooltipRect.width - 10;
                            }
                            if (left < 0) {
                                left = 10;
                            }
                            if (top < 0) {
                                top = canvasRect.top + pointPixelY + 10;
                            }
                            if (top + tooltipRect.height > bodyRect.height) {
                                top = bodyRect.height - tooltipRect.height - 10;
                            }
                        }
                    },
                    onMouseLeave: () => {
                        // 隐藏tooltip
                        document.getElementById('medicine-tooltip').style.display = 'none';
                    }
                }
            });

            // 不再自动显示最优价格点

            // 添加图表选择区域功能
            const chartCanvas = document.getElementById('medicine-chart');

            chartCanvas.addEventListener('mousedown', function(e) {
                isSelecting = true;
                const rect = chartCanvas.getBoundingClientRect();
                selectionStart.x = e.clientX - rect.left;
                selectionStart.y = e.clientY - rect.top;
                selectionEnd.x = selectionStart.x;
                selectionEnd.y = selectionStart.y;

                medicineSelection.style.display = 'block';
                medicineSelection.style.left = selectionStart.x + 'px';
                medicineSelection.style.top = selectionStart.y + 'px';
                medicineSelection.style.width = '0px';
                medicineSelection.style.height = '0px';
            });

            chartCanvas.addEventListener('mousemove', function(e) {
                if (!isSelecting) return;

                const rect = chartCanvas.getBoundingClientRect();
                selectionEnd.x = e.clientX - rect.left;
                selectionEnd.y = e.clientY - rect.top;

                const left = Math.min(selectionStart.x, selectionEnd.x);
                const top = Math.min(selectionStart.y, selectionEnd.y);
                const width = Math.abs(selectionEnd.x - selectionStart.x);
                const height = Math.abs(selectionEnd.y - selectionStart.y);

                medicineSelection.style.left = left + 'px';
                medicineSelection.style.top = top + 'px';
                medicineSelection.style.width = width + 'px';
                medicineSelection.style.height = height + 'px';
            });

            chartCanvas.addEventListener('mouseup', function(e) {
                if (!isSelecting) return;
                isSelecting = false;

                // 计算选择区域对应的价格范围
                const xScale = medicineChart.scales.x;
                const yScale = medicineChart.scales.y;

                const startX = xScale.getValueForPixel(selectionStart.x);
                const endX = xScale.getValueForPixel(selectionEnd.x);
                const startY = yScale.getValueForPixel(selectionStart.y);
                const endY = yScale.getValueForPixel(selectionEnd.y);

                const minPrice = Math.min(startX, endX);
                const maxPrice = Math.max(startX, endX);
                const maxIncome = Math.max(startY, endY);

                // 找出最优价格点
                let bestPrice = minPrice;
                let bestIncome = 0;

                for (let price = minPrice; price <= maxPrice; price += 10000) {
                    const fee = calculateMedicineFee(price);
                    const income = price - fee.fee;
                    if (income > bestIncome && income <= maxIncome) {
                        bestIncome = income;
                        bestPrice = price;
                    }
                }

                // 不再显示最优价格点

                // 延迟隐藏选择区域，让用户看到结果
                setTimeout(() => {
                    medicineSelection.style.display = 'none';
                }, 500);
            });
        }

        // 显示药品计算结果的函数
        function showMedicineCalculationResult(price, income, label) {
            // 创建或更新结果显示元素
            let resultDiv = document.getElementById('medicine-chart-result');
            if (!resultDiv) {
                resultDiv = document.createElement('div');
                resultDiv.id = 'medicine-chart-result';
                resultDiv.dataset.isUserInput = 'false';
                resultDiv.style.position = 'fixed';
                resultDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                resultDiv.style.color = 'white';
                resultDiv.style.padding = '10px';
                resultDiv.style.borderRadius = '5px';
                resultDiv.style.zIndex = '1000';
                document.querySelector('#medicine .chart-container').appendChild(resultDiv);
            }

            // 更新显示内容
            resultDiv.innerHTML = `
                <div><strong>${label}</strong></div>
                <div>价格: ${formatPrice(price)}</div>
                <div>实际收入: ${formatPrice(income)}</div>
            `;

            // 设置位置 - 固定在图表左上角
            const rect = document.getElementById('medicine-chart').getBoundingClientRect();
            
            // 使用固定定位，相对于视口
            resultDiv.style.position = 'fixed';
            resultDiv.style.left = (rect.left + 10) + 'px';
            resultDiv.style.top = (rect.top + 10) + 'px';
            resultDiv.style.transform = 'translate(0, 0)'; // 确保没有其他变换

            // 确保元素可见
            resultDiv.style.display = 'block';

            // 如果是用户输入的结果，延长显示时间
            const displayTime = label.includes('当前输入') ? 10000 : 5000;
            
            // 清除之前的定时器
            if (resultDiv.hideTimer) {
                clearTimeout(resultDiv.hideTimer);
            }
            
            // 不再自动隐藏结果，常驻显示
        }

        // 初始化装备图表
        function initEquipmentChart() {
            const ctx = document.getElementById('equipment-chart').getContext('2d');
            const entries = parseInt(document.getElementById('equipment-entries').value);
            const basePriceInput = document.getElementById('equipment-base-price').value;
            const basePrice = parsePriceInput(basePriceInput);
            const data = generateEquipmentChartData(entries, basePrice);
            const equipmentSelection = document.getElementById('equipment-selection');
            const equipmentPriceInput = document.getElementById('equipment-price');

            // 选择区域相关变量
            let isSelecting = false;
            let selectionStart = { x: 0, y: 0 };
            let selectionEnd = { x: 0, y: 0 };

            equipmentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: '实际收入',
                            data: data.chartData,
                            borderColor: 'rgba(54, 162, 235, 1)',
                            backgroundColor: 'rgba(54, 162, 235, 0.2)',
                            fill: true,
                            tension: 0.1,
                            pointRadius: 0,
                            // 确保线条只在有效数据范围内绘制
                            spanGaps: false,
                            // 设置数据边界
                            xAxisID: 'x'
                        },
                        {
                            label: '极值点',
                            data: data.extremePoints,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 1)',
                            pointRadius: 5,
                            pointHoverRadius: 7,
                            showLine: false
                        },
                        {
                            label: '最高点',
                            data: data.highestPoint ? [data.highestPoint] : [],
                            borderColor: 'rgba(255, 159, 64, 1)',
                            backgroundColor: 'rgba(255, 159, 64, 1)',
                            pointRadius: 10,
                            pointHoverRadius: 12,
                            pointStyle: 'circle',
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '期望售价'
                            },
                            ticks: {
                                callback: function(value) {
                                    // 显示所有合理的y轴刻度值
                                    if (value >= 0) {
                                        return formatPrice(value);
                                    }
                                    return '';
                                }
                            },
                            // 扩展显示区域，使用5%的范围作为边距
                            min: -data.maxX * 0.05,
                            max: data.maxX * 1.05,
                            // 添加一些边距，使图表不会紧贴边缘
                            afterBuildTicks: function(scale) {
                                scale.ticks = scale.ticks.map(function(tick) {
                                    return tick;
                                });
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '实际收入'
                            },
                            maxTicksLimit: 6,
                            ticks: {
                                callback: function(value) {
                                    // 显示所有合理的y轴刻度值
                                    if (value >= 0) {
                                        return formatPrice(value);
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    layout: {
                        padding: {
                            left: 10,
                            right: 20,
                            top: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        tooltip: {
                            enabled: false // 禁用Chart.js默认的tooltip
                        }
                    },
                    onHover: (event, activeElements) => {
                        const canvasPosition = Chart.helpers.getRelativePosition(event, equipmentChart);
                        let dataX = equipmentChart.scales.x.getValueForPixel(canvasPosition.x);
                        const dataY = equipmentChart.scales.y.getValueForPixel(canvasPosition.y);

                        // 检查是否有用户输入的结果，如果有则调整tooltip位置避免重叠
                        const resultDiv = document.getElementById('chart-result');
                        if (resultDiv && resultDiv.dataset.isUserInput === 'true') {
                            // 获取常驻结果的位置
                            const resultRect = resultDiv.getBoundingClientRect();
                            // 调整tooltip位置，避免与常驻结果重叠
                            const tooltip = document.getElementById('equipment-tooltip');
                            tooltip.style.display = 'block';
                            // 继续执行后续代码，显示tooltip
                        }

                        // 检查是否在最大值范围内
                        const data = equipmentChart.data.datasets[0].data;
                        const maxX = Math.max(...data.map(point => point.x));
                        const maxXRange = maxX * 0.02; // 最大值2%的范围

                        // 如果在最大值范围内，使用最大值
                        if (Math.abs(dataX - maxX) < maxXRange) {
                            dataX = maxX;
                        }

                        const tooltip = document.getElementById('equipment-tooltip');
                        tooltip.style.display = 'block';
                        const entries = parseInt(document.getElementById('equipment-entries').value);
                        const basePriceInput = document.getElementById('equipment-base-price').value;
                        const basePrice = parsePriceInput(basePriceInput);
                        const result = calculateEquipmentFee(dataX, entries, basePrice);
                        tooltip.innerHTML = `
                            <table class="tooltip-table">
                                <tr><td>期望售价:</td><td>${formatPrice(dataX)}</td></tr>
                                <tr><td>手续费率:</td><td>${result.feeRate.toFixed(2)}%</td></tr>
                                <tr><td>手续费:</td><td>${formatPrice(result.fee)}</td></tr>
                                <tr><td>实际收入:</td><td>${formatPrice(result.actualIncome)}</td></tr>
                            </table>
                        `;

                        // 使用鼠标位置定位tooltip，并确保不超出body边界
                        const tooltipRect = tooltip.getBoundingClientRect();
                        const bodyRect = document.body.getBoundingClientRect();

                        let left = event.native.clientX - bodyRect.left + 10;
                        let top = event.native.clientY - bodyRect.top - tooltipRect.height - 10;

                        // 如果有常驻结果显示，调整tooltip位置避免重叠
                        if (resultDiv && resultDiv.dataset.isUserInput === 'true') {
                            const resultRect = resultDiv.getBoundingClientRect();
                            // 如果tooltip会与常驻结果重叠，则调整位置
                            if (left < resultRect.right && left + tooltipRect.width > resultRect.left &&
                                top < resultRect.bottom && top + tooltipRect.height > resultRect.top) {
                                // 将tooltip移到常驻结果的右侧
                                left = resultRect.right + 10;
                                // 如果右侧超出边界，则移到下方
                                if (left + tooltipRect.width > bodyRect.width) {
                                    left = event.native.clientX - bodyRect.left - tooltipRect.width - 10;
                                    // 如果还是超出边界，则移到常驻结果的下方
                                    if (left < 0) {
                                        left = resultRect.left;
                                        top = resultRect.bottom + 10;
                                    }
                                }
                            }
                        }

                        // 检查右边界
                        if (left + tooltipRect.width > bodyRect.width) {
                            left = event.native.clientX - bodyRect.left - tooltipRect.width - 10;
                        }

                        // 检查左边界
                        if (left < 0) {
                            left = 10;
                        }

                        // 检查下边界
                        if (top < 0) {
                            top = event.native.clientY - bodyRect.top + 10;
                        }

                        // 检查上边界
                        if (top + tooltipRect.height > bodyRect.height) {
                            top = bodyRect.height - tooltipRect.height - 10;
                        }

                        tooltip.style.left = left + 'px';
                        tooltip.style.top = top + 'px';

                        // 检查是否靠近极值点
                        let nearExtremePoint = false;
                        let extremePointData = null;
                        const extremePoints = data.extremePoints || [];
                        for (const point of extremePoints) {
                            const distance = Math.abs(point.x - dataX);
                            if (distance < 1000000) { // 如果距离小于100万
                                nearExtremePoint = true;
                                extremePointData = point;
                                break;
                            }
                        }

                        // 检查是否靠近最高点
                        let nearHighestPoint = false;
                        let highestPointData = null;
                        const highestPoint = data.highestPoint;
                        if (highestPoint && !nearExtremePoint) {
                            const distance = Math.abs(highestPoint.x - dataX);
                            if (distance < 1000000) { // 如果距离小于100万
                                nearHighestPoint = true;
                                highestPointData = highestPoint;
                            }
                        }

                        // 如果靠近极值点或最高点，使用它们的值
                        let displayDataX = dataX;
                        if (nearExtremePoint) {
                            displayDataX = extremePointData.x;
                        } else if (nearHighestPoint) {
                            displayDataX = highestPointData.x;
                        }

                        const equipmentEntries = parseInt(document.getElementById('equipment-entries').value);
                        const equipmentBasePriceInput = document.getElementById('equipment-base-price').value;
                        const equipmentBasePrice = parsePriceInput(equipmentBasePriceInput);
                        const equipmentResult = calculateEquipmentFee(displayDataX, equipmentEntries, equipmentBasePrice);
                        tooltip.innerHTML = `
                            <table class="tooltip-table">
                                <tr><td>期望售价:</td><td>${formatPrice(displayDataX)}</td></tr>
                                <tr><td>手续费率:</td><td>${equipmentResult.feeRate.toFixed(2)}%</td></tr>
                                <tr><td>手续费:</td><td>${formatPrice(equipmentResult.fee)}</td></tr>
                                <tr><td>实际收入:</td><td>${formatPrice(equipmentResult.actualIncome)}</td></tr>
                                ${nearExtremePoint ? '<tr><td colspan="2" style="text-align:center;color:#FF6384;font-weight:bold;">极值点</td></tr>' : ''}
                                ${nearHighestPoint ? '<tr><td colspan="2" style="text-align:center;color:#FF9F40;font-weight:bold;">最高点</td></tr>' : ''}
                            </table>
                        `;

                        // 如果靠近极值点或最高点，调整tooltip位置
                        if (nearExtremePoint || nearHighestPoint) {
                            const point = nearExtremePoint ? extremePointData : highestPointData;
                            const pointPixelX = equipmentChart.scales.x.getPixelForValue(point.x);
                            const pointPixelY = equipmentChart.scales.y.getPixelForValue(point.y);
                            const canvasRect = equipmentChart.canvas.getBoundingClientRect();
                            
                            left = canvasRect.left + pointPixelX + 10;
                            top = canvasRect.top + pointPixelY - tooltipRect.height - 10;
                            
                            // 确保tooltip不超出边界
                            if (left + tooltipRect.width > bodyRect.width) {
                                left = canvasRect.left + pointPixelX - tooltipRect.width - 10;
                            }
                            if (left < 0) {
                                left = 10;
                            }
                            if (top < 0) {
                                top = canvasRect.top + pointPixelY + 10;
                            }
                            if (top + tooltipRect.height > bodyRect.height) {
                                top = bodyRect.height - tooltipRect.height - 10;
                            }
                        }
                    },
                    onMouseLeave: () => {
                        // 隐藏tooltip
                        document.getElementById('equipment-tooltip').style.display = 'none';
                    }
                }
            });

            // 不再自动显示最优价格点

            // 添加图表选择区域功能
            const chartCanvas = document.getElementById('equipment-chart');

            chartCanvas.addEventListener('mousedown', function(e) {
                isSelecting = true;
                const rect = chartCanvas.getBoundingClientRect();
                selectionStart.x = e.clientX - rect.left;
                selectionStart.y = e.clientY - rect.top;
                selectionEnd.x = selectionStart.x;
                selectionEnd.y = selectionStart.y;

                equipmentSelection.style.display = 'block';
                equipmentSelection.style.left = selectionStart.x + 'px';
                equipmentSelection.style.top = selectionStart.y + 'px';
                equipmentSelection.style.width = '0px';
                equipmentSelection.style.height = '0px';
            });

            chartCanvas.addEventListener('mousemove', function(e) {
                if (!isSelecting) return;

                const rect = chartCanvas.getBoundingClientRect();
                selectionEnd.x = e.clientX - rect.left;
                selectionEnd.y = e.clientY - rect.top;

                const left = Math.min(selectionStart.x, selectionEnd.x);
                const top = Math.min(selectionStart.y, selectionEnd.y);
                const width = Math.abs(selectionEnd.x - selectionStart.x);
                const height = Math.abs(selectionEnd.y - selectionStart.y);

                equipmentSelection.style.left = left + 'px';
                equipmentSelection.style.top = top + 'px';
                equipmentSelection.style.width = width + 'px';
                equipmentSelection.style.height = height + 'px';
            });

            chartCanvas.addEventListener('mouseup', function(e) {
                if (!isSelecting) return;
                isSelecting = false;

                // 计算选择区域对应的价格范围
                const xScale = equipmentChart.scales.x;
                const yScale = equipmentChart.scales.y;

                const startX = xScale.getValueForPixel(selectionStart.x);
                const endX = xScale.getValueForPixel(selectionEnd.x);
                const startY = yScale.getValueForPixel(selectionStart.y);
                const endY = yScale.getValueForPixel(selectionEnd.y);

                const minPrice = Math.min(startX, endX);
                const maxPrice = Math.max(startX, endX);
                const maxIncome = Math.max(startY, endY);

                // 找出最优价格点
                let bestPrice = minPrice;
                let bestIncome = 0;
                const entries = parseInt(document.getElementById('equipment-entries').value);
                const basePriceInput = document.getElementById('equipment-base-price').value;
                const basePrice = parsePriceInput(basePriceInput);

                for (let price = minPrice; price <= maxPrice; price += 10000) {
                    const result = calculateEquipmentFee(price, entries, basePrice);
                    const income = result.actualIncome;
                    if (income > bestIncome && income <= maxIncome) {
                        bestIncome = income;
                        bestPrice = price;
                    }
                }

                // 延迟隐藏选择区域，让用户看到结果
                setTimeout(() => {
                    equipmentSelection.style.display = 'none';
                }, 500);
            });
        }

        // 计算药品
        function calculateMedicine() {
            const priceInput = document.getElementById('medicine-price').value;
            const price = parsePriceInput(priceInput);
            const result = calculateMedicineFee(price);

            // 在图表上标记当前点
            if (medicineChart) {
                // 添加或更新当前点数据集
                let currentPointDataset = medicineChart.data.datasets.find(dataset => dataset.label === '当前输入');

                if (!currentPointDataset) {
                    medicineChart.data.datasets.push({
                        label: '当前输入',
                        data: [{x: result.price, y: result.actualIncome}],
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 1)',
                        pointRadius: 7,
                        pointHoverRadius: 9,
                        showLine: false
                    });
                } else {
                    currentPointDataset.data = [{x: result.price, y: result.actualIncome}];
                }

                medicineChart.update('none'); // 使用'none'模式避免动画，确保立即更新
            }
            
            // 显示计算结果
            if (result && result.price && result.actualIncome) {
                showMedicineCalculationResult(result.price, result.actualIncome, '当前输入价格');
                // 标记为用户输入的结果
                const resultDiv = document.getElementById('medicine-chart-result');
                if (resultDiv) {
                    resultDiv.dataset.isUserInput = 'true';
                }
            }
        }

        // 计算装备
        function calculateEquipment() {
            const priceInput = document.getElementById('equipment-price').value;
            const price = parsePriceInput(priceInput);
            const basePriceInput = document.getElementById('equipment-base-price').value;
            const basePrice = parsePriceInput(basePriceInput);
            const entries = parseInt(document.getElementById('equipment-entries').value);
            const result = calculateEquipmentFee(price, entries, basePrice);

            // 在图表上标记当前点
            if (equipmentChart) {
                // 添加或更新当前点数据集
                let currentPointDataset = equipmentChart.data.datasets.find(dataset => dataset.label === '当前输入');

                if (!currentPointDataset) {
                    equipmentChart.data.datasets.push({
                        label: '当前输入',
                        data: [{x: result.price, y: result.actualIncome}],
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 1)',
                        pointRadius: 7,
                        pointHoverRadius: 9,
                        showLine: false
                    });
                } else {
                    currentPointDataset.data = [{x: result.price, y: result.actualIncome}];
                }


                equipmentChart.update('none'); // 使用'none'模式避免动画，确保立即更新
            }
            
            // 显示计算结果
            if (result && result.price && result.actualIncome) {
                showCalculationResult(result.price, result.actualIncome, '当前输入价格');
                // 标记为用户输入的结果
                const resultDiv = document.getElementById('chart-result');
                if (resultDiv) {
                    resultDiv.dataset.isUserInput = 'true';
                }
            }
        }

        // 显示计算结果的函数
        function showCalculationResult(price, income, label) {
            // 创建或更新结果显示元素
            let resultDiv = document.getElementById('chart-result');
            if (!resultDiv) {
                resultDiv = document.createElement('div');
                resultDiv.id = 'chart-result';
                resultDiv.dataset.isUserInput = 'false';
                resultDiv.style.position = 'fixed';
                resultDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                resultDiv.style.color = 'white';
                resultDiv.style.padding = '10px';
                resultDiv.style.borderRadius = '5px';
                resultDiv.style.zIndex = '1000';
                document.querySelector('#equipment .chart-container').appendChild(resultDiv);
            }

            // 更新显示内容
            resultDiv.innerHTML = `
                <div><strong>${label}</strong></div>
                <div>价格: ${formatPrice(price)}</div>
                <div>实际收入: ${formatPrice(income)}</div>
            `;

            // 设置位置 - 固定在图表左上角
            const rect = document.getElementById('equipment-chart').getBoundingClientRect();
            
            // 使用固定定位，相对于视口
            resultDiv.style.position = 'fixed';
            resultDiv.style.left = (rect.left + 10) + 'px';
            resultDiv.style.top = (rect.top + 10) + 'px';
            resultDiv.style.transform = 'translate(0, 0)'; // 确保没有其他变换

            // 确保元素可见
            resultDiv.style.display = 'block';

            // 如果是用户输入的结果，延长显示时间
            const displayTime = label.includes('当前输入') ? 10000 : 5000;
            
            // 清除之前的定时器
            if (resultDiv.hideTimer) {
                clearTimeout(resultDiv.hideTimer);
            }
            
            // 不再自动隐藏结果，常驻显示
        }

        // 更新表格数据
        function updateDataTable(data) {
            const tbody = document.getElementById('equipment-data-points');
            if (!tbody) return; // 如果元素不存在，直接返回
            tbody.innerHTML = '';
            
            // 添加极值点
            const extremePoints = data.extremePoints || [];
            extremePoints.forEach((point, index) => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>极值点 ${index + 1}</td>
                    <td>${formatPrice(point.x)}</td>
                    <td>${formatPrice(point.y)}</td>
                    <td>${point.feeRate}%</td>
                `;
            });
            
            // 添加最高点
            if (data.highestPoint) {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>最高点</td>
                    <td>${formatPrice(data.highestPoint.x)}</td>
                    <td>${formatPrice(data.highestPoint.y)}</td>
                    <td>${data.highestPoint.feeRate}%</td>
                `;
                // 高亮最高点行
                row.style.backgroundColor = 'rgba(75, 192, 192, 0.2)';
            }
        }

        // 词条数变化时更新图表
        document.getElementById('equipment-entries').addEventListener('change', function() {
            if (equipmentChart) {
                const entries = parseInt(this.value);
                const basePriceInput = document.getElementById('equipment-base-price').value;
                const basePrice = parsePriceInput(basePriceInput);
                const data = generateEquipmentChartData(entries, basePrice);

                // 更新图表数据
                equipmentChart.data.datasets[0].data = data.chartData || [];
                equipmentChart.data.datasets[1].data = data.extremePoints || [];
                equipmentChart.data.datasets[2].data = data.highestPoint ? [data.highestPoint] : [];
                equipmentChart.options.scales.x.max = data.maxX;
                
                // 计算并设置y轴最大值
                const maxYValue = Math.max(...data.chartData.map(d => d.y));
                equipmentChart.options.scales.y.max = maxYValue * 1.2; // 增加20%的上边距

                // 移除当前点
                const currentPointIndex = equipmentChart.data.datasets.findIndex(dataset => dataset.label === '当前输入');
                if (currentPointIndex !== -1) {
                    equipmentChart.data.datasets.splice(currentPointIndex, 1);
                }

                // 更新图表
                equipmentChart.update();

                // 更新表格数据
                updateDataTable(data);
            }
        });

        // 统一回收价变化时更新图表
        document.getElementById('equipment-base-price').addEventListener('change', function() {
            if (equipmentChart) {
                const entries = parseInt(document.getElementById('equipment-entries').value);
                const basePriceInput = this.value;
                const basePrice = parsePriceInput(basePriceInput);
                const data = generateEquipmentChartData(entries, basePrice);

                // 更新图表数据
                equipmentChart.data.datasets[0].data = data.chartData || [];
                equipmentChart.data.datasets[1].data = data.extremePoints || [];
                equipmentChart.data.datasets[2].data = data.highestPoint ? [data.highestPoint] : [];
                equipmentChart.options.scales.x.max = data.maxX;
                
                // 计算并设置y轴最大值
                const maxYValue = Math.max(...data.chartData.map(d => d.y));
                equipmentChart.options.scales.y.max = maxYValue * 1.2; // 增加20%的上边距

                // 移除当前点
                const currentPointIndex = equipmentChart.data.datasets.findIndex(dataset => dataset.label === '当前输入');
                if (currentPointIndex !== -1) {
                    equipmentChart.data.datasets.splice(currentPointIndex, 1);
                }

                // 更新图表
                equipmentChart.update();

                // 更新表格数据
                updateDataTable(data);
            }
        });

        // 初始化药品图表
        initMedicineChart();
        // 初始化装备图表
        initEquipmentChart();

        // 添加药品价格输入监听，实现实时计算
        document.getElementById('medicine-price').addEventListener('input', function() {
            if (this.value.trim()) {
                calculateMedicine();
            } else {
                document.getElementById('medicine-result').style.display = 'none';
            }
        });

        // 添加装备价格输入监听，实现实时计算
        document.getElementById('equipment-price').addEventListener('input', function() {
            if (this.value.trim()) {
                calculateEquipment();
            } else {
                document.getElementById('equipment-result').style.display = 'none';
            }
        });
    </script>
</body>
</html>
